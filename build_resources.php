<?php
  
  
  $R = array();
  $R['images'] = array();
  $R['animationGroups'] = array();
  $R['imageSlices'] = array();
  $R['sliceNames'] = array();
  
  $DATA = json_decode(file_get_contents('sprites/data.json'), true);
  foreach ($DATA['textures'] as $textureName => $texture) {
    $SLICES = json_decode(file_get_contents("sprites/textures/$textureName.json"), true);
    copy("sprites/textures/$textureName.png", "res/$textureName.png");
    $R['images'][$textureName] = array(
      'filename' => "res/$textureName.png",
      'imageModifiers' => 1 | 2 | 4, // XXX
    );
    
    $R['sliceNames'] = $SLICES;

    $R['imageSlices'][$textureName] = array_values($SLICES);
    $SLICES = array_combine(array_keys($SLICES), range(0, count($SLICES)-1)); // map slice filenames to indicies in $R['imageSlices'][$textureName]
    
    foreach ($texture['characters'] as $characterName => $character) {
      $animations = array();
      foreach ($character['animations'] as $animationName => $animation) {
        $frames = array();
        foreach ($animation['frames'] as $frame) {
          $frame['slice'] = $SLICES[$frame['slice']];
          $frames[] = $frame;
        }
        $animations[$animationName] = array(
          'loop'   => $animation['loop'],
          'frames' => $frames,
        );
      }
      $R['animationGroups'][$characterName] = array(
        'image'     => $textureName,
        'sequences' => $animations,
      );
    }
  }
  
  file_put_contents('src/R.sprites.js', "// DO NOT EDIT THIS FILE: it is automatically generated by build_resources.php\n\n_.extend(R, \n" . json_encode($R) . "\n);\n");
  
  
  //$R = permissiveJsonLoad('src/R.part');
  //if (!$R) { die("Could not parse JSON in R.part! Make sure keys are double-quoted!"); }
  $R = array();
  $R['areas'] = array();
  
  // load areas from maps/*.tmx
  foreach (glob('maps/*.tmx') as $mapFile) {
    preg_match('#/(.*)\.\w+$#', $mapFile, $matches);
    $filelabel = $matches[1];
    
    $xml = null;
    $parser = xml_parser_create();
    xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);
    xml_parse_into_struct($parser, file_get_contents($mapFile), $xml, $xmlIndex);
    xml_parser_free($parser);
    $tileLayers = array();
    $objects    = array();
    $object = null;
    $layerName = '';
    foreach ($xml as $tag) {
      $attr = @$tag['attributes'];
      if ($tag['tag'] === 'layer') {
        $layerName = @$attr['name'];
      }
      elseif ($tag['tag'] === 'data') {
        $data = $tag['value'];
        $tiles = null;
        if ($attr['encoding'] === 'base64' && $attr['compression'] === 'zlib') {
          $tiles = array_values(unpack('V*', gzuncompress(base64_decode($tag['value']))));
        }
        elseif ($attr['encoding'] === 'csv') {
          $tiles = array_map('intval', explode(',', $tag['value']));
        }
        else {
          die("Resource $mapFile - unknown tile data encoding/compression");
        }
        
        if ($layerName === 'physics') {
          $tiles = array_map('clampToOne', $tiles);
        }
        elseif ($layerName === 'background') {
          $tiles = array_map('minusOne', $tiles);
        }
        else {
          die("Resource $mapFile - an object has an unknown tile layer name '$layerName'");
        }
        $tileLayers[$layerName] = $tiles;
      }
      elseif ($tag['tag'] === 'property') {
        $object['properties'][ $attr['name'] ] = $attr['value'];
      }
      elseif ($tag['tag'] === 'object') {
        
        // if this is an open tag, we'll need to wait for the close tag (and collect properties in the meantime)
        if ($tag['type'] === 'open' || $tag['type'] === 'complete') {
          $object = $attr;
          $object['properties'] = array();
        }
        
        if ($tag['type'] === 'close' || $tag['type'] === 'complete') {
          
          if (!@$object['name']) { die("Resource $mapFile - an object is missing a name"); }
          if (!@$object['type']) { die("Resource $mapFile - an object is missing a type"); }
          
          if ($object['type'] === 'exit') {
            $objects['exit'][] = array_merge(array(
              'area'   => $object['name'],
              'hitbox' => array( 'x1' => (double)$object['x'], 'y1' => (double)$object['y'], 'x2' => (double)$object['x'] + (double)$object['width'], 'y2' => (double)$object['y'] + (double)$object['height'] ),
            ), $object['properties']);
          }
          elseif ($object['type'] === 'spawn') {
            $objects['spawn'][] = array_merge(array(
              'class' => $object['name'],
              'x'     => (double)$object['x'],
              'y'     => (double)$object['y'],
            ), $object['properties']);
          }
          else {
            die("Resource $mapFile - an object has an unknown type '{$object['type']}'");
          }
        }
      }
    }
    
    $R['areas'][$filelabel] = array(
      'image'      => 'tiles',
      'tileSize'   => (int)$xml[0]['attributes']['tilewidth'],
      'cols'       => (int)$xml[0]['attributes']['width'],
      'physics'    => $tileLayers['physics'],
      'background' => $tileLayers['background'],
      'exits'      => $objects['exit'],
      'spawns'     => $objects['spawn'],
    );
  }
  
  //file_put_contents('src/R.js', "// DO NOT EDIT THIS FILE (edit R.part instead)\n\nvar R =\n" . json_encode($R) . "\n;\n");
  
  file_put_contents('src/R.areas.js', "// DO NOT EDIT THIS FILE: it is automatically generated by build_resources.php\n\n_.extend(R, \n" . json_encode($R) . "\n);\n");
  
  /*
  // load areas from maps/*.json
  foreach (glob('maps/*.json') as $mapFile) {
    preg_match('#/(.*)\.\w+$#', $mapFile, $matches);
    $filelabel = $matches[1];
    $mapData = json_decode(file_get_contents($mapFile), true);
    $physics    = null;
    $background = null;
    $exits      = array();
    $spawns     = array();
    foreach ($mapData['layers'] as $layer) {
      if ($layer['type'] === 'tilelayer') {
        if ($layer['name'] === 'physics') {
          $physics = array_map('clampToOne', $layer['data']);
        }
        elseif ($layer['name'] === 'background') {
          $background = array_map('minusOne', $layer['data']);
        }
        else {
          die("Resource $mapFile - unknown tilelayer found!");
        }
      }
      elseif ($layer['type'] === 'objectgroup') {
        foreach ($layer['objects'] as $object) {
          if (!@$object['name']) { die("Resource $mapFile - an object is missing a name"); }
          if (!@$object['type']) { die("Resource $mapFile - an object is missing a type"); }
          if ($object['type'] === 'exit') {
            $exits[] = array_merge(array(
              'area'   => $object['name'],
              'hitbox' => array( 'x1' => $object['x'], 'y1' => $object['y'], 'x2' => $object['x'] + $object['width'], 'y2' => $object['y'] + $object['height'] ),
            ), $object['properties']);
          }
          elseif ($object['type'] === 'spawn') {
            $spawns[] = array_merge(array(
              'class' => $object['name'],
              'x'     => $object['x'],
              'y'     => $object['y'],
            ), $object['properties']);
          }
          else {
            die("Resource $mapFile - an object has an unknown type");
          }
        }
      }
      else {
        die("Resource $mapFile - unknown layer found");
      }
    }
    $R['areas'][$filelabel] = array(
      'image'      => 'tiles',
      'tileSize'   => $mapData['tileheight'],
      'cols'       => $mapData['width'],
      'physics'    => $physics,
      'background' => $background,
      'exits'      => $exits,
      'spawns'     => $spawns,
    );
  }
  */
  
  //
  function minusOne($n) { return $n - 1; }
  function clampToOne($n) { return $n ? 1 : 0; }
  
  //
  function permissiveJsonLoad($filename) {
    $json = file_get_contents($filename);
    $json = preg_replace('/^[^{]*/', '', $json);     // remove prefixed "var X ="
    $json = preg_replace('/;\s*$/', '', $json);      // remove trailing ";"
    $json = preg_replace('#/\*.*?\*/#s', '', $json); // remove "/* comments */"
    $json = preg_replace('#//.*#', '', $json);       // remove '// comments"
    $json = preg_replace('/,\s*\]/s', ']', $json);   // remove trailing commas in arrays
    $json = preg_replace('/,\s*\}/s', '}', $json);   // remove trailing commas in objects
    return json_decode($json, true);
  }
  
  //
  function showme($var) {
    echo "<xmp>" . print_r($var, true) . "</xmp>\n";
  }

?>